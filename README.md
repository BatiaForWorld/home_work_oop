# Домашняя работа ООП — модели Product и Category

## Описание проекта

Это домашнее задание по теме "ООП: классы и атрибуты" включает два основных класса: `Product` и `Category`.

### Архитектура проекта

Проект состоит из двух основных классов, которые моделируют предметную область электронной коммерции:

#### Класс `Product` (Товар)

Представляет отдельный товар в системе. Каждый экземпляр содержит:

- **`name`** (str) — название товара (например, "Samsung Galaxy S23 Ultra")
- **`description`** (str) — подробное описание товара с характеристиками
- **`price`** (float) — цена товара в рублях (поддерживает дробные значения для копеек)
- **`quantity`** (int) — количество товара в наличии на складе

**Особенности реализации:**
- Автоматическое приведение типов в конструкторе (`price` к `float`, `quantity` к `int`)
- Переопределённые методы `__str__` и `__repr__` для красивого отображения товара
- Магический метод `__add__` для подсчета общей стоимости товаров на складе
- Приватный атрибут `__price` с геттером и сеттером для валидации
- Класс-метод `new_product()` для создания из словарей
- Типизация атрибутов для лучшей читаемости кода

#### Класс `Category` (Категория)

Представляет категорию товаров, которая может содержать несколько продуктов. Каждый экземпляр содержит:

- **`name`** (str) — название категории (например, "Смартфоны", "Телевизоры")
- **`description`** (str) — описание категории
- **`products`** (list) — список объектов `Product`, принадлежащих данной категории

**Атрибуты класса (общие для всех экземпляров):**
- **`category_count`** (int) — общее количество созданных категорий
- **`product_count`** (int) — общее количество товаров во всех категориях

**Особенности реализации:**
- Автоматическое обновление счётчиков при создании новой категории
- Приватный атрибут `__products` для защиты данных
- Геттер `products` с форматированным выводом через `str(product)`
- Метод `add_product()` для безопасного добавления товаров
- Магический метод `__str__` для отображения общего количества товаров на складе
- Создание копии переданного списка товаров для инкапсуляции данных
- Подсчёт товаров происходит по длине списка, а не по количеству на складе

### Бизнес-логика

1. **Учёт товаров**: Каждый товар имеет базовые атрибуты, необходимые для ведения каталога
2. **Организация в категории**: Товары группируются по категориям для удобной навигации
3. **Глобальная статистика**: Система автоматически ведёт учёт общего количества категорий и товаров
4. **Типобезопасность**: Все атрибуты имеют явную типизацию


## Техническая реализация

Реализованы простые классы :

- `Product` — хранит `name`, `description`, `price` (float) и `quantity` (int).
- `Category` — хранит `name`, `description` и список продуктов `products`.

Класс `Category` имеет два атрибута класса:

- `category_count` — автоматически увеличивается при создании нового объекта категории.
- `product_count` — суммарное количество продуктов во всех созданных категориях (сумма длин списков).

## Управление проектом с Poetry

Проект использует **Poetry** для управления зависимостями, виртуального окружения и автоматизации задач.

### Установка зависимостей

```bash
poetry add pytest pytest-cov flake8 black isort mypy
```

### Активация виртуального окружения

```bash
poetry init
```

### Запуск основной программы

```bash
python src/14.1_main.py  # Демонстрация базовой функциональности
python src/14.2_main.py  # Демонстрация инкапсуляции и приватных атрибутов  
python src/15.1_main.py  # Демонстрация магических методов
```

### Тестирование

Тесты находятся в `tests/test_models.py` и проверяют:
- Корректную инициализацию объектов и работу счётчиков
- Инкапсуляцию и приватные атрибуты
- Геттеры и сеттеры с валидацией
- Класс-методы для создания объектов
- Магические методы (`__str__`, `__repr__`, `__add__`)
- Обработку ошибочных ситуаций

**Статистика тестирования:**
- Всего тестов: **25**
- Покрытие кода: **100%** (включая branch coverage)
- Все тесты используют фикстуры из `tests/conftest.py`

Запуск тестов:

```bash
pytest
```


Запуск тестов с покрытием кода:

```bash
pytest --cov
```

### Проверка качества кода

Проверка соответствия PEP8 с помощью flake8:

```bash
flake8 src
```

Форматирование кода с помощью black:

```bash
black src
```

Сортировка импортов с помощью isort:

```bash
isort src
```

Типизация с помощью mypy:

```bash
mypy src
```

### Требования к качеству кода

-  По результатам проверки линтером flake8 в коде **0 ошибок** по PEP 8
-  Покрытие функционального кода тестами **100%** (превышает требуемые 85%)
-  Все **25 тестов** проходят успешно
-  Код соответствует всем принципам ООП и инкапсуляции

## Нововведения в версии 14.2

### Инкапсуляция и защита данных

В версии 14.2 реализованы принципы инкапсуляции для защиты критически важных данных:

#### Класс `Product`

**Приватные атрибуты:**
- **`__price`** — цена товара теперь защищена от прямого доступа извне

**Новые методы:**
- **`@property price`** — геттер для получения цены товара
- **`@price.setter`** — сеттер с валидацией цены:
  - Проверяет, что цена положительная (> 0)
  - Выводит сообщение "Цена не должна быть нулевая или отрицательная" при некорректном значении
  - Сохраняет старое значение цены при попытке установить некорректное

**Класс-методы:**
- **`@classmethod new_product(cls, product_data)`** — создание продукта из словаря с ключами:
  - `name` — название товара
  - `description` — описание товара  
  - `price` — цена товара
  - `quantity` — количество на складе

#### Класс `Category`

**Приватные атрибуты:**
- **`__products`** — список товаров теперь защищён от прямого внешнего доступа

**Новые методы:**
- **`@property products`** — геттер, возвращающий отформатированную строку с товарами:
  - Формат: "Название продукта, X руб. Остаток: X шт.\n"
  - Каждый товар выводится на новой строке
- **`add_product(product)`** — безопасный способ добавления товара в категорию:
  - Принимает объект класса `Product`
  - Автоматически увеличивает счётчик `product_count`
  - Добавляет товар в приватный список `__products`

### Преимущества новой архитектуры

1. **Безопасность данных** — приватные атрибуты защищают от случайного некорректного изменения
2. **Валидация** — автоматическая проверка корректности вводимых данных
3. **Контролируемый доступ** — все изменения данных происходят через специальные методы
4. **Форматированный вывод** — автоматическое форматирование данных для отображения пользователю
5. **Удобство создания объектов** — класс-методы упрощают инициализацию из структурированных данных

### Обратная совместимость

Внешний API классов остался прежним:
- Доступ к цене: `product.price` 
- Доступ к списку товаров: `category.products`
- Добавление товаров: `category.add_product(product)`
- Создание товаров: `Product.new_product(data)`

### Покрытие тестами

- Общее покрытие кода тестами: **96%**
- Все новые функции полностью покрыты тестами
- Тесты проверяют как корректную работу, так и обработку ошибочных ситуаций

## Нововведения в версии 15.1

### Магические методы и улучшенное взаимодействие

В версии 15.1 реализованы магические методы для более естественного взаимодействия с объектами:

#### Класс `Product`

**Обновленные магические методы:**

- **`__str__()`** — строковое представление продукта в формате:
  ```
  "Название продукта, X руб. Остаток: X шт."
  ```
  
- **`__repr__()`** — техническое представление продукта в формате:
  ```
  "Название продукта - X₽"
  ```

- **`__add__(other)`** — магический метод сложения для подсчета общей стоимости товаров:
  - Вычисляет сумму произведений цены на количество для двух продуктов
  - Формула: `(price1 × quantity1) + (price2 × quantity2)`
  - Возвращает `NotImplemented` для несовместимых типов
  - Пример: `product_a + product_b` → общая стоимость товаров на складе

#### Класс `Category`

**Обновленные магические методы:**

- **`__str__()`** — строковое представление категории в формате:
  ```
  "Название категории, количество продуктов: X шт."
  ```
  - Подсчитывает общее количество товаров на складе (сумма `quantity` всех продуктов)

**Оптимизация геттера `products`:**
- Теперь использует `str(product)` для формирования списка товаров
- Более эффективная и читаемая реализация

### Примеры использования новых возможностей

```python
# Создание продуктов
product1 = Product("iPhone 15", "512GB, Gray space", 210000.0, 8)
product2 = Product("Samsung Galaxy", "256GB, Серый", 180000.0, 5)

# Красивое отображение продуктов
print(product1)  # iPhone 15, 210000.0 руб. Остаток: 8 шт.
print(repr(product2))  # Samsung Galaxy - 180000.0₽

# Подсчет общей стоимости товаров на складе
total_value = product1 + product2
print(total_value)  # 2580000.0 (210000*8 + 180000*5)

# Создание категории
category = Category("Смартфоны", "Мобильные устройства", [product1, product2])
print(category)  # Смартфоны, количество продуктов: 13 шт.

# Отформатированный список товаров
print(category.products)
# iPhone 15, 210000.0 руб. Остаток: 8 шт.
# Samsung Galaxy, 180000.0 руб. Остаток: 5 шт.
```

### Технические улучшения

1. **Интуитивное взаимодействие** — объекты ведут себя естественно при использовании встроенных функций Python
2. **Математические операции** — возможность складывать продукты для получения общей стоимости
3. **Читаемый вывод** — все объекты имеют понятное строковое представление
4. **Безопасность типов** — корректная обработка операций с несовместимыми типами



- В проекте присутствуют классы-наследники: `Smartphone` (с полями efficiency, model, memory, color) и `LawnGrass` (с полями country, germination_period, color), оба наследуют от `Product`.
- Сложение товаров реализовано только между объектами одного и того же класса (например, два смартфона). При попытке сложить разные типы товаров выбрасывается `TypeError`.
- Метод `add_product` класса `Category` принимает только объекты класса `Product` или его наследников. При попытке добавить другой тип выбрасывается `TypeError`.
- Присутствуют тесты для новых классов и ограничений, покрытие кода тестами сохраняется выше 95%.
- Добавлен абстрактный базовый класс `BaseProduct` с обязательными методами `__str__` и `__repr__`
- Реализован миксин `MixinLog` для логирования создания объектов  
- Класс `Product` теперь использует множественное наследование: `Product(MixinLog, BaseProduct)`
- Классы `Smartphone` и `LawnGrass` наследуются только от `Product`
- При создании любого продукта автоматически выводится сообщение о логировании
- Реализована валидация количества товара при создании экземпляра класса `Product`
- При попытке создать товар с нулевым или отрицательным количеством выбрасывается исключение `ValueError` 
- Реализован метод `average_price()` в классе `Category` для расчета среднего ценника всех товаров
- Метод `middle_price()` для совместимости с существующим кодом
- Обработка случая пустой категории через блок `try/except` - возвращается 0 при отсутствии товаров


